<!DOCTYPE html>
<html lang="pl-pl">

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <script type="application/ld+json">
    {
        "@context" : "http://schema.org",
        "@type" : "BlogPosting",
        "mainEntityOfPage": {
             "@type": "WebPage",
             "@id": "https://smyrdek.com/"
        },
        "articleSection" : "posts",
        "name" : "Applying CQRS to Product Design",
        "headline" : "Applying CQRS to Product Design",
        "description" : "Software engineers know most of the benefits that CQRS bring to the table, so maybe we could borrow the same concept to a bit different domain — let’s say — design?",
        "inLanguage" : "pl-PL",
        "author" : "Przemek Smyrdek",
        "creator" : "Przemek Smyrdek",
        "publisher": "Przemek Smyrdek",
        "accountablePerson" : "Przemek Smyrdek",
        "copyrightHolder" : "Przemek Smyrdek",
        "copyrightYear" : "2019",
        "datePublished": "2019-03-04 18:25:15 &#43;0100 CET",
        "dateModified" : "2019-03-04 18:25:15 &#43;0100 CET",
        "url" : "https://smyrdek.com/posts/applying-cqrs-to-product-design/",
        "wordCount" : "1145",
        "keywords" : [ "cqrs","design","english","srp","Blog" ]
    }
</script>
  
  <title>Applying CQRS to Product Design - Przemek Smyrdek - O rozwoju, nie tylko w programowaniu</title>
  
  <meta name="description" content="Do you know what the CQRS is? Command Query Responsibility Segregation is an architectural pattern used heavily in all kinds of back-end systems, which basically tells you that commands (mutations of the state) should be separated from the queries (parts where you read the data, i.e. for the purpose of UI or reporting).
There are multiple reasons why engineers apply this pattern to their projects, but these two are probably worth mentioning the most:">
  <meta name="author" content="Przemek Smyrdek">
  
  <link href="https://smyrdek.com/css/font.css" rel="stylesheet">
  <link href="https://smyrdek.com/css/atom-one-dark.min.css" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,400i,700,700i" rel="stylesheet">
  <link href="https://smyrdek.com/css/style.css" rel="stylesheet">
  
  <link rel="apple-touch-icon" href="https://smyrdek.com/img/apple-touch-icon.png">
  <link rel="icon" href="https://smyrdek.com/img/favicon.ico">
  
  <meta name="generator" content="Hugo 0.52" />
  
  <link rel="alternate" type="application/atom+xml" href="https://smyrdek.com/index.xml" title="Przemek Smyrdek - O rozwoju, nie tylko w programowaniu">
  
  
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-130241188-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

  

  <meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://smyrdek.com/images/cqrs.png"/>

<meta name="twitter:title" content="Applying CQRS to Product Design"/>
<meta name="twitter:description" content="Software engineers know most of the benefits that CQRS bring to the table, so maybe we could borrow the same concept to a bit different domain — let’s say — design?"/>

  <meta property="og:title" content="Applying CQRS to Product Design" />
<meta property="og:description" content="Software engineers know most of the benefits that CQRS bring to the table, so maybe we could borrow the same concept to a bit different domain — let’s say — design?" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://smyrdek.com/posts/applying-cqrs-to-product-design/" />
<meta property="og:image" content="https://smyrdek.com/images/cqrs.png" />
<meta property="article:published_time" content="2019-03-04T18:25:15&#43;01:00"/>
<meta property="article:modified_time" content="2019-03-04T18:25:15&#43;01:00"/>

</head>

<body class="single">
  <header class="header">
    <div class="blog-title">
      <h1 class="title"><a href="https://smyrdek.com/">przemek<span class="blog-address">smyrdek.com</span></a></h1>
    </div>
    <div class="menu-wide">
      
        <a href="https://smyrdek.com/about-me/">About Me</a>
      
        <a href="https://smyrdek.com/covers/">Covers</a>
      
        <a href="https://smyrdek.com/contact/">Contact</a>
      
    </div>
    <div class="menu-mobile">
      <button class="menu-toggle" type="button"></button>
      <nav class="menu">
        <ul>
          
          
          <li class="">
            <a href="https://smyrdek.com/about-me/">About Me</a>
          </li>
          
          <li class="">
            <a href="https://smyrdek.com/covers/">Covers</a>
          </li>
          
          <li class="">
            <a href="https://smyrdek.com/contact/">Contact</a>
          </li>
          
        </ul>
      </nav>
    </div>
  </header>
  <main class="main">
<article class="post post-view">
  <header class="post-header">
    <h1 class="post-title">Applying CQRS to Product Design</h1>
    <p class="post-meta">Przemek Smyrdek · 04.03.2019</p>
  </header>
  <div class="post-content">

<p><img src="https://smyrdek.com/images/cqrs.png" alt="cqrs" /></p>

<p>Do you know what the CQRS is? Command Query Responsibility Segregation is an architectural pattern used heavily in all kinds of back-end systems, which basically tells you that commands (mutations of the state) should be separated from the queries (parts where you read the data, i.e. for the purpose of UI or reporting).</p>

<p>There are multiple reasons why engineers apply this pattern to their projects, but these two are probably worth mentioning the most:</p>

<p>Firstly, CQRS fits well into this concept of so-called “Single Responsibility Principle” — one of the fundamentals of software engineering. SRP is all about creating things that do just one thing — no mixed concerns, no phone calls while driving, just one thing at a time. By applying CQRS pattern into your system, as a side effect, you are following the SRP rule — you can keep the codebase cleaner, make the maintenance easier, and let reason about a given part of the project without any hassle.</p>

<p>Secondly, CQRS helps you organize your system in a totally different way for the purpose of reads and writes. For example, there may be modules on top of which users run tons of reports every day, so the “read parts” of them have to be as performant as possible. By splitting queries from commands you can be focused on polishing just one thing (reporting queries) at a given point in time, so there’s less risk that other parts will break by mistake.</p>

<p>Software engineers know most of the benefits that CQRS bring to the table, so maybe we could borrow the same concept to a bit different domain — let’s say — design?</p>

<h2 id="commands-or-queries-reads-or-writes">Commands or queries? Reads or writes?</h2>

<p>Multiple times in my life I’ve seen (or even built) interfaces that are trying to achieve too many things at once. Imagine the profile page of your favorite social media platform — there’s a non-zero chance that somewhere next to your name there’s this “Edit profile” button that turns labels into forms and inputs you can interact with to update your profile data:</p>

<p><img src="https://smyrdek.com/images/cqrs-profile.png" alt="" /></p>

<p>Sure, in some cases this type of UI/UX lets you complete the task of updating your data relatively fast, but it ruins both read and write experience. Why?
Imagine that there would be some kind of a source of knowledge where readability is a priority. The priority for you would be to make it easy for the consumers to gather most of the knowledge from this mysterious thing in the most efficient way, so you would have to spend lots of time on setting up all the margins and padding properly, picking the right font size, font type and maybe a letter spacing. We could say that “read mode” would be the most important feature of this mysterious thing.</p>

<p>Actually, it’s not that mysterious — it’s called a book. For books and other sources of written knowledge readability is a must have.</p>

<p><img src="https://smyrdek.com/images/cqrs-book.png" alt="" /></p>

<p>Now imagine that you are applying the same UI patterns of the tool that helped you to write a book (like MS Word), to the book itself. Instead of nice spacing between the lines, pretty fonts and useful margins you’d need to introduce completely different experience to find a room for all the buttons, labels, actions, notifications and scrollbars. MS Word is primarily about getting the writers&rsquo; job done, not about making the readers&rsquo; life easier (that’s the role of DTP).</p>

<p><img src="https://smyrdek.com/images/cqrs-word.png" alt="" /></p>

<p>For sure this is not the kind of book we would recommend to our friends, right?</p>

<h2 id="do-one-thing-well">Do one thing well</h2>

<p>So this is where CQRS-like pattern comes into action in the context of design. For software engineers, separating reads from writes helps in creating systems that are easier to reason about and easier to tune up. For designers, the approach which is conceptually very similar helps in creating experiences that your users appreciate and
understand.</p>

<p>The example that came to my mind when I started thinking about it was Wordpress. Wordpress, as a platform, contains hundreds of thousands of layouts that improve the look, feeling and readability of the content you create. The same Wordpress contains just one text editor that has nothing to do with the layout of your blog, yet it helps you create the content that empowers it. Uploading the new layout does not break the editor. Updating the editor does not break the layout. As simple as that.</p>

<p>Do you see why the case I previously mentioned (inline data editing) breaks the read/write separation?</p>

<ul>
<li>If we want to find a room for both read-only data, and data editors, we need to sacrifice one of these two — readability, or robustness.</li>
<li>If we want to let people execute two actions using the same part of UI, we may either complicate the workflow of gathering the data, or limit the one of uploading / writing it to the system</li>
<li>If someone has to actually implement this kind of UI, it may be hard to distinguish components that present the data from ones that modify it.</li>
</ul>

<p>Knowing all of this, how could we solve the case of editing the profile data? One of the simpler examples would be to create a dedicated page where all the forms and inputs would serve solely to the purpose of “edit workflow”.</p>

<p><img src="https://smyrdek.com/images/cqrs-form.png" alt="" /></p>

<p>Relatively small margins and padding, call to actions that are easy to understand, dedicated loading indicators, empty states, and so on. No limitations from the perspective of profile page UI, no limitations from the perspective of where this data is being presented, etc. Pure editing experience. Commands, instead of queries.</p>

<p>A huge benefit you could gain from this approach would be in getting rid of all the constraints of presenting the data in read-only mode. No “I need to find a room for edit form”, no “How to hide these inputs next to the labels”, no “The font is too big for editing the data”. Feel free to introduce a bit bigger letter spacing, bigger font size, and fancy margins. No edit forms attached. Think about queries, instead of writes.
—
So that’s how I see it. As an engineer, from time to time I was trying to learn more about the CQRS pattern and all those positives it brings when applied.</p>

<p>Recently I found the connection between the same idea and the world of product design and today I’m trying to share this with you. Of course, it’s not “one fits all” solution, and there will be cases where inline edit forms work better than the solution presented here, but I hope that my post may help you reconsider or balance some of the design decisions you make during your regular workday.</p>

<p>I’m really eager to see your point of view on this. Do you find such a perspective useful? Do you think that inline editing provides a better experience for the user? Let me know in the comments!</p>
</div>
  <footer class="post-footer">
    
    <ul class="post-tags">
      
      <li><a href="https://smyrdek.com/tags/cqrs/">#cqrs</a></li>
      
      <li><a href="https://smyrdek.com/tags/design/">#design</a></li>
      
      <li><a href="https://smyrdek.com/tags/english/">#english</a></li>
      
      <li><a href="https://smyrdek.com/tags/srp/">#srp</a></li>
      
    </ul>
    
  </footer>
  
  
  
  <div id="disqus_thread"></div>
  <script>
    var disqus_shortname = 'przemeksmyrdek';
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  </script>
  <noscript>
    Please enable JavaScript to view the
    <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
  </noscript>
  
  
  
</article>
</main>
<footer class="footer">
  
  <ul class="social-links">
    <li><a href="https://twitter.com/psmyrdek"><img src="https://smyrdek.com/images/shared/social/twitter-64.png" alt="Twitter logo" /></a></li>
    <li><a href="https://github.com/psmyrdek/"><img src="https://smyrdek.com/images/shared/social/github-64.png" alt="GitHub logo" /></a></li>
    <li><a href="https://www.linkedin.com/in/psmyrdek/"><img src="https://smyrdek.com/images/shared/social/linkedin-64.png" alt="LinkedIn logo" /></a></li>
  </ul>

  <span>&copy; 2019 Przemek Smyrdek - O rozwoju, nie tylko w programowaniu</span>
</footer>
<script src="https://smyrdek.com/js/instantclick.min.js" data-no-instant></script>
<script data-no-instant>InstantClick.init();</script>
<script src="https://smyrdek.com/js/highlight.min.js" data-no-instant></script>
<script data-no-instant>
  addMenuListener();
  InstantClick.on('change', function () {
    addMenuListener();
  });
  function addMenuListener() {
    var $toggle = document.querySelector('.menu-toggle');
    var $body = document.querySelector('body');
    $toggle.addEventListener('click', function () {
      $body.classList.toggle('noscroll');
    }, false);
  }
</script>
</body>

</html>
